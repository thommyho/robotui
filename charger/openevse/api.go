// Package openevse provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.11.0 DO NOT EDIT.
package openevse

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
)

// Defines values for LogEventType.
const (
	Information  LogEventType = "information"
	Notification LogEventType = "notification"
	Warning      LogEventType = "warning"
)

// Defines values for ScheduleEventDays.
const (
	Friday    ScheduleEventDays = "friday"
	Monday    ScheduleEventDays = "monday"
	Saturday  ScheduleEventDays = "saturday"
	Sunday    ScheduleEventDays = "sunday"
	Thursday  ScheduleEventDays = "thursday"
	Tuesday   ScheduleEventDays = "tuesday"
	Wednesday ScheduleEventDays = "wednesday"
)

// LogEvent defines model for LogEvent.
type LogEvent struct {
	DivertMode *int32   `json:"divertMode,omitempty"`
	Elapsed    *int32   `json:"elapsed,omitempty"`
	Energy     *float64 `json:"energy,omitempty"`
	EvseFlags  *int32   `json:"evseFlags,omitempty"`
	EvseState  *int     `json:"evseState,omitempty"`

	// Either enable charging (`active`) or block charging (`disabled`)
	ManagerState   *string       `json:"managerState,omitempty"`
	Pilot          *int32        `json:"pilot,omitempty"`
	Temperature    *float64      `json:"temperature,omitempty"`
	TempuratureMax *float64      `json:"tempuratureMax,omitempty"`
	Time           *time.Time    `json:"time,omitempty"`
	Type           *LogEventType `json:"type,omitempty"`
}

// LogEventType defines model for LogEvent.Type.
type LogEventType string

// Message defines model for Message.
type Message struct {
	// The message
	Msg *string `json:"msg,omitempty"`
}

// ScheduleEvent defines model for ScheduleEvent.
type ScheduleEvent struct {
	Days []ScheduleEventDays `json:"days"`
	Id   *int                `json:"id,omitempty"`

	// Either enable charging (`active`) or block charging (`disabled`)
	State string `json:"state"`
	Time  string `json:"time"`
}

// ScheduleEventDays defines model for ScheduleEvent.Days.
type ScheduleEventDays string

// BadRequest defines model for BadRequest.
type BadRequest = Message

// NotFound defines model for NotFound.
type NotFound = Message

// UpdateSuccessful defines model for UpdateSuccessful.
type UpdateSuccessful = Message

// SetClaimJSONBody defines parameters for SetClaim.
type SetClaimJSONBody struct {
	// `true` if the manual override is auto-released when the vehicle is
	// disconnected, `false` if manual override will persist after vehicle
	// disconnection.
	AutoRelease *bool `json:"auto_release,omitempty"`

	// Specify the active charge current in Amps
	ChargeCurrent *int `json:"charge_current,omitempty"`

	// Stop the charge after `energy_limit` Wh of energy have been transfered.
	//
	// > Note:  Not currently implemented
	EnergyLimit *int32 `json:"energy_limit,omitempty"`

	// Dynamically alter the max current while still allowing other claims to very the current via `charge_current` that can not exceede this value. This is primerialy designed for load sharing situations while still allowing things like PV divert to work so the charge current is the minimum of `charge_current` <= `max_current` <= configured soft limit <= hard coded limit
	MaxCurrent *int `json:"max_current,omitempty"`

	// Either enable charging (`active`) or block charging (`disabled`)
	State *string `json:"state,omitempty"`

	// Stop the charge after the duration of the charging session has exceeded `time_limit` seconds
	//
	// > Note:  Not currently implemented
	TimeLimit *int32 `json:"time_limit,omitempty"`
}

// UpdateConfigJSONBody defines parameters for UpdateConfig.
type UpdateConfigJSONBody struct {
	Buildenv                    *string   `json:"buildenv,omitempty"`
	ChargeMode                  *string   `json:"charge_mode,omitempty"`
	DiodeCheck                  *bool     `json:"diode_check,omitempty"`
	DivertPVRatio               *float32  `json:"divert_PV_ratio,omitempty"`
	DivertAttackSmoothingFactor *float32  `json:"divert_attack_smoothing_factor,omitempty"`
	DivertDecaySmoothingFactor  *float32  `json:"divert_decay_smoothing_factor,omitempty"`
	DivertEnabled               *bool     `json:"divert_enabled,omitempty"`
	DivertMinChargeTime         *float32  `json:"divert_min_charge_time,omitempty"`
	EmoncmsApikey               *string   `json:"emoncms_apikey,omitempty"`
	EmoncmsEnabled              *bool     `json:"emoncms_enabled,omitempty"`
	EmoncmsFingerprint          *string   `json:"emoncms_fingerprint,omitempty"`
	EmoncmsNode                 *string   `json:"emoncms_node,omitempty"`
	EmoncmsServer               *string   `json:"emoncms_server,omitempty"`
	Espflash                    *float32  `json:"espflash,omitempty"`
	Espinfo                     *string   `json:"espinfo,omitempty"`
	Firmware                    *string   `json:"firmware,omitempty"`
	Flags                       *float32  `json:"flags,omitempty"`
	GfciCheck                   *bool     `json:"gfci_check,omitempty"`
	GroundCheck                 *bool     `json:"ground_check,omitempty"`
	Hostname                    *string   `json:"hostname,omitempty"`
	HttpSupportedProtocols      *[]string `json:"http_supported_protocols,omitempty"`
	LedBrightness               *float32  `json:"led_brightness,omitempty"`
	MaxCurrentHard              *int      `json:"max_current_hard,omitempty"`
	MaxCurrentSoft              *int      `json:"max_current_soft,omitempty"`
	MinCurrentHard              *int      `json:"min_current_hard,omitempty"`
	MqttAnnounceTopic           *string   `json:"mqtt_announce_topic,omitempty"`
	MqttEnabled                 *bool     `json:"mqtt_enabled,omitempty"`
	MqttGridIe                  *string   `json:"mqtt_grid_ie,omitempty"`
	MqttPass                    *string   `json:"mqtt_pass,omitempty"`
	MqttPort                    *int      `json:"mqtt_port,omitempty"`
	MqttProtocol                *string   `json:"mqtt_protocol,omitempty"`
	MqttRejectUnauthorized      *bool     `json:"mqtt_reject_unauthorized,omitempty"`
	MqttServer                  *string   `json:"mqtt_server,omitempty"`
	MqttSolar                   *string   `json:"mqtt_solar,omitempty"`
	MqttSupportedProtocols      *[]string `json:"mqtt_supported_protocols,omitempty"`
	MqttTopic                   *string   `json:"mqtt_topic,omitempty"`
	MqttUser                    *string   `json:"mqtt_user,omitempty"`
	MqttVehicleEta              *string   `json:"mqtt_vehicle_eta,omitempty"`
	MqttVehicleRange            *string   `json:"mqtt_vehicle_range,omitempty"`
	MqttVehicleRangeMiles       *bool     `json:"mqtt_vehicle_range_miles,omitempty"`
	MqttVehicleSoc              *string   `json:"mqtt_vehicle_soc,omitempty"`
	MqttVrms                    *string   `json:"mqtt_vrms,omitempty"`
	OcppChargeBoxId             *string   `json:"ocpp_chargeBoxId,omitempty"`
	OcppEnabled                 *bool     `json:"ocpp_enabled,omitempty"`
	OcppEnergizePlug            *bool     `json:"ocpp_energize_plug,omitempty"`
	OcppIdTag                   *string   `json:"ocpp_idTag,omitempty"`
	OcppServer                  *string   `json:"ocpp_server,omitempty"`
	OcppSuspendEvse             *bool     `json:"ocpp_suspend_evse,omitempty"`
	Offset                      *int      `json:"offset,omitempty"`
	Ohm                         *string   `json:"ohm,omitempty"`
	OhmEnabled                  *bool     `json:"ohm_enabled,omitempty"`
	Pass                        *string   `json:"pass,omitempty"`
	PauseUsesDisabled           *bool     `json:"pause_uses_disabled,omitempty"`
	Protocol                    *string   `json:"protocol,omitempty"`
	RelayCheck                  *bool     `json:"relay_check,omitempty"`
	Scale                       *int      `json:"scale,omitempty"`
	Service                     *int      `json:"service,omitempty"`
	SntpEnabled                 *bool     `json:"sntp_enabled,omitempty"`
	SntpHostname                *string   `json:"sntp_hostname,omitempty"`
	Ssid                        *string   `json:"ssid,omitempty"`
	TempCheck                   *bool     `json:"temp_check,omitempty"`
	TeslaAccessToken            *string   `json:"tesla_access_token,omitempty"`
	TeslaCreatedAt              *float32  `json:"tesla_created_at,omitempty"`
	TeslaEnabled                *bool     `json:"tesla_enabled,omitempty"`
	TeslaExpiresIn              *float32  `json:"tesla_expires_in,omitempty"`
	TeslaRefreshToken           *string   `json:"tesla_refresh_token,omitempty"`
	TeslaVehicleId              *string   `json:"tesla_vehicle_id,omitempty"`
	TimeZone                    *string   `json:"time_zone,omitempty"`
	TxStartPoint                *string   `json:"tx_start_point,omitempty"`
	VentCheck                   *bool     `json:"vent_check,omitempty"`
	Version                     *string   `json:"version,omitempty"`
	WwwPassword                 *string   `json:"www_password,omitempty"`
	WwwUsername                 *string   `json:"www_username,omitempty"`
}

// SetManualOverrideJSONBody defines parameters for SetManualOverride.
type SetManualOverrideJSONBody struct {
	// `true` if the manual override is auto-released when the vehicle is
	// disconnected, `false` if manual override will persist after vehicle
	// disconnection.
	AutoRelease *bool `json:"auto_release,omitempty"`

	// Specify the active charge current in Amps
	ChargeCurrent *int `json:"charge_current,omitempty"`

	// Stop the charge after `energy_limit` Wh of energy have been transfered.
	//
	// > Note:  Not currently implemented
	EnergyLimit *int32 `json:"energy_limit,omitempty"`

	// Dynamically alter the max current while still allowing other claims to very the current via `charge_current` that can not exceede this value. This is primerialy designed for load sharing situations while still allowing things like PV divert to work so the charge current is the minimum of `charge_current` <= `max_current` <= configured soft limit <= hard coded limit
	MaxCurrent *int `json:"max_current,omitempty"`

	// Either enable charging (`active`) or block charging (`disabled`)
	State *string `json:"state,omitempty"`

	// Stop the charge after the duration of the charging session has exceeded `time_limit` seconds
	//
	// > Note:  Not currently implemented
	TimeLimit *int32 `json:"time_limit,omitempty"`
}

// UpdateScheduleJSONBody defines parameters for UpdateSchedule.
type UpdateScheduleJSONBody = []ScheduleEvent

// SetScheduleEventJSONBody defines parameters for SetScheduleEvent.
type SetScheduleEventJSONBody = string

// SetClaimJSONRequestBody defines body for SetClaim for application/json ContentType.
type SetClaimJSONRequestBody SetClaimJSONBody

// UpdateConfigJSONRequestBody defines body for UpdateConfig for application/json ContentType.
type UpdateConfigJSONRequestBody UpdateConfigJSONBody

// SetManualOverrideJSONRequestBody defines body for SetManualOverride for application/json ContentType.
type SetManualOverrideJSONRequestBody SetManualOverrideJSONBody

// UpdateScheduleJSONRequestBody defines body for UpdateSchedule for application/json ContentType.
type UpdateScheduleJSONRequestBody = UpdateScheduleJSONBody

// SetScheduleEventJSONRequestBody defines body for SetScheduleEvent for application/json ContentType.
type SetScheduleEventJSONRequestBody = SetScheduleEventJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListClaims request
	ListClaims(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReleaseClaim request
	ReleaseClaim(ctx context.Context, client int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetClaim request
	GetClaim(ctx context.Context, client int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetClaim request with any body
	SetClaimWithBody(ctx context.Context, client int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetClaim(ctx context.Context, client int, body SetClaimJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetConfig request
	GetConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateConfig request with any body
	UpdateConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateConfig(ctx context.Context, body UpdateConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEventBlockInfo request
	GetEventBlockInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetEventBlock request
	GetEventBlock(ctx context.Context, index int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClearManualOverride request
	ClearManualOverride(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetManualOverride request
	GetManualOverride(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ToggleManualOverride request
	ToggleManualOverride(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetManualOverride request with any body
	SetManualOverrideWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetManualOverride(ctx context.Context, body SetManualOverrideJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSchedule request
	ListSchedule(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateSchedule request with any body
	UpdateScheduleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateSchedule(ctx context.Context, body UpdateScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RemoveScheduleEvent request
	RemoveScheduleEvent(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetScheduleEvent request
	GetScheduleEvent(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetScheduleEvent request with any body
	SetScheduleEventWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetScheduleEvent(ctx context.Context, id int, body SetScheduleEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStatus request
	GetStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTeslaVehicles request
	GetTeslaVehicles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StatusUpdates request
	StatusUpdates(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListClaims(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListClaimsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReleaseClaim(ctx context.Context, client int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReleaseClaimRequest(c.Server, client)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetClaim(ctx context.Context, client int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetClaimRequest(c.Server, client)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetClaimWithBody(ctx context.Context, client int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetClaimRequestWithBody(c.Server, client, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetClaim(ctx context.Context, client int, body SetClaimJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetClaimRequest(c.Server, client, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetConfig(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateConfigWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateConfigRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateConfig(ctx context.Context, body UpdateConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateConfigRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEventBlockInfo(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEventBlockInfoRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetEventBlock(ctx context.Context, index int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetEventBlockRequest(c.Server, index)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClearManualOverride(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClearManualOverrideRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetManualOverride(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetManualOverrideRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ToggleManualOverride(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewToggleManualOverrideRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetManualOverrideWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetManualOverrideRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetManualOverride(ctx context.Context, body SetManualOverrideJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetManualOverrideRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSchedule(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListScheduleRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateScheduleWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateScheduleRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateSchedule(ctx context.Context, body UpdateScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateScheduleRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RemoveScheduleEvent(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRemoveScheduleEventRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetScheduleEvent(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetScheduleEventRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetScheduleEventWithBody(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetScheduleEventRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetScheduleEvent(ctx context.Context, id int, body SetScheduleEventJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetScheduleEventRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStatus(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStatusRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTeslaVehicles(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTeslaVehiclesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StatusUpdates(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStatusUpdatesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListClaimsRequest generates requests for ListClaims
func NewListClaimsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/claims")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReleaseClaimRequest generates requests for ReleaseClaim
func NewReleaseClaimRequest(server string, client int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "client", runtime.ParamLocationPath, client)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/claims/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetClaimRequest generates requests for GetClaim
func NewGetClaimRequest(server string, client int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "client", runtime.ParamLocationPath, client)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/claims/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetClaimRequest calls the generic SetClaim builder with application/json body
func NewSetClaimRequest(server string, client int, body SetClaimJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetClaimRequestWithBody(server, client, "application/json", bodyReader)
}

// NewSetClaimRequestWithBody generates requests for SetClaim with any type of body
func NewSetClaimRequestWithBody(server string, client int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "client", runtime.ParamLocationPath, client)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/claims/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetConfigRequest generates requests for GetConfig
func NewGetConfigRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateConfigRequest calls the generic UpdateConfig builder with application/json body
func NewUpdateConfigRequest(server string, body UpdateConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateConfigRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateConfigRequestWithBody generates requests for UpdateConfig with any type of body
func NewUpdateConfigRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetEventBlockInfoRequest generates requests for GetEventBlockInfo
func NewGetEventBlockInfoRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/logs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetEventBlockRequest generates requests for GetEventBlock
func NewGetEventBlockRequest(server string, index int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "index", runtime.ParamLocationPath, index)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/logs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewClearManualOverrideRequest generates requests for ClearManualOverride
func NewClearManualOverrideRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/override")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetManualOverrideRequest generates requests for GetManualOverride
func NewGetManualOverrideRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/override")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewToggleManualOverrideRequest generates requests for ToggleManualOverride
func NewToggleManualOverrideRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/override")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetManualOverrideRequest calls the generic SetManualOverride builder with application/json body
func NewSetManualOverrideRequest(server string, body SetManualOverrideJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetManualOverrideRequestWithBody(server, "application/json", bodyReader)
}

// NewSetManualOverrideRequestWithBody generates requests for SetManualOverride with any type of body
func NewSetManualOverrideRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/override")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListScheduleRequest generates requests for ListSchedule
func NewListScheduleRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schedule")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateScheduleRequest calls the generic UpdateSchedule builder with application/json body
func NewUpdateScheduleRequest(server string, body UpdateScheduleJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateScheduleRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateScheduleRequestWithBody generates requests for UpdateSchedule with any type of body
func NewUpdateScheduleRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schedule")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewRemoveScheduleEventRequest generates requests for RemoveScheduleEvent
func NewRemoveScheduleEventRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schedule/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetScheduleEventRequest generates requests for GetScheduleEvent
func NewGetScheduleEventRequest(server string, id int) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schedule/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetScheduleEventRequest calls the generic SetScheduleEvent builder with application/json body
func NewSetScheduleEventRequest(server string, id int, body SetScheduleEventJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetScheduleEventRequestWithBody(server, id, "application/json", bodyReader)
}

// NewSetScheduleEventRequestWithBody generates requests for SetScheduleEvent with any type of body
func NewSetScheduleEventRequestWithBody(server string, id int, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/schedule/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetStatusRequest generates requests for GetStatus
func NewGetStatusRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTeslaVehiclesRequest generates requests for GetTeslaVehicles
func NewGetTeslaVehiclesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tesla/vehicles")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewStatusUpdatesRequest generates requests for StatusUpdates
func NewStatusUpdatesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ws")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListClaims request
	ListClaimsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListClaimsResponse, error)

	// ReleaseClaim request
	ReleaseClaimWithResponse(ctx context.Context, client int, reqEditors ...RequestEditorFn) (*ReleaseClaimResponse, error)

	// GetClaim request
	GetClaimWithResponse(ctx context.Context, client int, reqEditors ...RequestEditorFn) (*GetClaimResponse, error)

	// SetClaim request with any body
	SetClaimWithBodyWithResponse(ctx context.Context, client int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetClaimResponse, error)

	SetClaimWithResponse(ctx context.Context, client int, body SetClaimJSONRequestBody, reqEditors ...RequestEditorFn) (*SetClaimResponse, error)

	// GetConfig request
	GetConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConfigResponse, error)

	// UpdateConfig request with any body
	UpdateConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateConfigResponse, error)

	UpdateConfigWithResponse(ctx context.Context, body UpdateConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateConfigResponse, error)

	// GetEventBlockInfo request
	GetEventBlockInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetEventBlockInfoResponse, error)

	// GetEventBlock request
	GetEventBlockWithResponse(ctx context.Context, index int, reqEditors ...RequestEditorFn) (*GetEventBlockResponse, error)

	// ClearManualOverride request
	ClearManualOverrideWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ClearManualOverrideResponse, error)

	// GetManualOverride request
	GetManualOverrideWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetManualOverrideResponse, error)

	// ToggleManualOverride request
	ToggleManualOverrideWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ToggleManualOverrideResponse, error)

	// SetManualOverride request with any body
	SetManualOverrideWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetManualOverrideResponse, error)

	SetManualOverrideWithResponse(ctx context.Context, body SetManualOverrideJSONRequestBody, reqEditors ...RequestEditorFn) (*SetManualOverrideResponse, error)

	// ListSchedule request
	ListScheduleWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListScheduleResponse, error)

	// UpdateSchedule request with any body
	UpdateScheduleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateScheduleResponse, error)

	UpdateScheduleWithResponse(ctx context.Context, body UpdateScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateScheduleResponse, error)

	// RemoveScheduleEvent request
	RemoveScheduleEventWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*RemoveScheduleEventResponse, error)

	// GetScheduleEvent request
	GetScheduleEventWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetScheduleEventResponse, error)

	// SetScheduleEvent request with any body
	SetScheduleEventWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetScheduleEventResponse, error)

	SetScheduleEventWithResponse(ctx context.Context, id int, body SetScheduleEventJSONRequestBody, reqEditors ...RequestEditorFn) (*SetScheduleEventResponse, error)

	// GetStatus request
	GetStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStatusResponse, error)

	// GetTeslaVehicles request
	GetTeslaVehiclesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTeslaVehiclesResponse, error)

	// StatusUpdates request
	StatusUpdatesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*StatusUpdatesResponse, error)
}

type ListClaimsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// `true` if the manual override is auto-released when the vehicle is
		// disconnected, `false` if manual override will persist after vehicle
		// disconnection.
		AutoRelease *bool `json:"auto_release,omitempty"`

		// Specify the active charge current in Amps
		ChargeCurrent *int `json:"charge_current,omitempty"`

		// The client ID, defined by [OpenEVSE](src/evse_man.h#L25)
		Client *int `json:"client,omitempty"`

		// Stop the charge after `energy_limit` Wh of energy have been transfered.
		//
		// > Note:  Not currently implemented
		EnergyLimit *int32 `json:"energy_limit,omitempty"`

		// Dynamically alter the max current while still allowing other claims to very the current via `charge_current` that can not exceede this value. This is primerialy designed for load sharing situations while still allowing things like PV divert to work so the charge current is the minimum of `charge_current` <= `max_current` <= configured soft limit <= hard coded limit
		MaxCurrent *int `json:"max_current,omitempty"`

		// The priority of the claim, the higher the number the higher the priority
		Priority *int `json:"priority,omitempty"`

		// Either enable charging (`active`) or block charging (`disabled`)
		State *string `json:"state,omitempty"`

		// Stop the charge after the duration of the charging session has exceeded `time_limit` seconds
		//
		// > Note:  Not currently implemented
		TimeLimit *int32 `json:"time_limit,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ListClaimsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListClaimsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReleaseClaimResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Message
	JSON404      *Message
}

// Status returns HTTPResponse.Status
func (r ReleaseClaimResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReleaseClaimResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetClaimResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// `true` if the manual override is auto-released when the vehicle is
		// disconnected, `false` if manual override will persist after vehicle
		// disconnection.
		AutoRelease *bool `json:"auto_release,omitempty"`

		// Specify the active charge current in Amps
		ChargeCurrent *int `json:"charge_current,omitempty"`

		// Stop the charge after `energy_limit` Wh of energy have been transfered.
		//
		// > Note:  Not currently implemented
		EnergyLimit *int32 `json:"energy_limit,omitempty"`

		// Dynamically alter the max current while still allowing other claims to very the current via `charge_current` that can not exceede this value. This is primerialy designed for load sharing situations while still allowing things like PV divert to work so the charge current is the minimum of `charge_current` <= `max_current` <= configured soft limit <= hard coded limit
		MaxCurrent *int `json:"max_current,omitempty"`

		// Either enable charging (`active`) or block charging (`disabled`)
		State *string `json:"state,omitempty"`

		// Stop the charge after the duration of the charging session has exceeded `time_limit` seconds
		//
		// > Note:  Not currently implemented
		TimeLimit *int32 `json:"time_limit,omitempty"`
	}
	JSON404 *Message
}

// Status returns HTTPResponse.Status
func (r GetClaimResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetClaimResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetClaimResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Message
	JSON400      *Message
}

// Status returns HTTPResponse.Status
func (r SetClaimResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetClaimResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Buildenv                    *string   `json:"buildenv,omitempty"`
		ChargeMode                  *string   `json:"charge_mode,omitempty"`
		DiodeCheck                  *bool     `json:"diode_check,omitempty"`
		DivertPVRatio               *float32  `json:"divert_PV_ratio,omitempty"`
		DivertAttackSmoothingFactor *float32  `json:"divert_attack_smoothing_factor,omitempty"`
		DivertDecaySmoothingFactor  *float32  `json:"divert_decay_smoothing_factor,omitempty"`
		DivertEnabled               *bool     `json:"divert_enabled,omitempty"`
		DivertMinChargeTime         *float32  `json:"divert_min_charge_time,omitempty"`
		EmoncmsApikey               *string   `json:"emoncms_apikey,omitempty"`
		EmoncmsEnabled              *bool     `json:"emoncms_enabled,omitempty"`
		EmoncmsFingerprint          *string   `json:"emoncms_fingerprint,omitempty"`
		EmoncmsNode                 *string   `json:"emoncms_node,omitempty"`
		EmoncmsServer               *string   `json:"emoncms_server,omitempty"`
		Espflash                    *float32  `json:"espflash,omitempty"`
		Espinfo                     *string   `json:"espinfo,omitempty"`
		Firmware                    *string   `json:"firmware,omitempty"`
		Flags                       *float32  `json:"flags,omitempty"`
		GfciCheck                   *bool     `json:"gfci_check,omitempty"`
		GroundCheck                 *bool     `json:"ground_check,omitempty"`
		Hostname                    *string   `json:"hostname,omitempty"`
		HttpSupportedProtocols      *[]string `json:"http_supported_protocols,omitempty"`
		LedBrightness               *float32  `json:"led_brightness,omitempty"`
		MaxCurrentHard              *int      `json:"max_current_hard,omitempty"`
		MaxCurrentSoft              *int      `json:"max_current_soft,omitempty"`
		MinCurrentHard              *int      `json:"min_current_hard,omitempty"`
		MqttAnnounceTopic           *string   `json:"mqtt_announce_topic,omitempty"`
		MqttEnabled                 *bool     `json:"mqtt_enabled,omitempty"`
		MqttGridIe                  *string   `json:"mqtt_grid_ie,omitempty"`
		MqttPass                    *string   `json:"mqtt_pass,omitempty"`
		MqttPort                    *int      `json:"mqtt_port,omitempty"`
		MqttProtocol                *string   `json:"mqtt_protocol,omitempty"`
		MqttRejectUnauthorized      *bool     `json:"mqtt_reject_unauthorized,omitempty"`
		MqttServer                  *string   `json:"mqtt_server,omitempty"`
		MqttSolar                   *string   `json:"mqtt_solar,omitempty"`
		MqttSupportedProtocols      *[]string `json:"mqtt_supported_protocols,omitempty"`
		MqttTopic                   *string   `json:"mqtt_topic,omitempty"`
		MqttUser                    *string   `json:"mqtt_user,omitempty"`
		MqttVehicleEta              *string   `json:"mqtt_vehicle_eta,omitempty"`
		MqttVehicleRange            *string   `json:"mqtt_vehicle_range,omitempty"`
		MqttVehicleRangeMiles       *bool     `json:"mqtt_vehicle_range_miles,omitempty"`
		MqttVehicleSoc              *string   `json:"mqtt_vehicle_soc,omitempty"`
		MqttVrms                    *string   `json:"mqtt_vrms,omitempty"`
		OcppChargeBoxId             *string   `json:"ocpp_chargeBoxId,omitempty"`
		OcppEnabled                 *bool     `json:"ocpp_enabled,omitempty"`
		OcppEnergizePlug            *bool     `json:"ocpp_energize_plug,omitempty"`
		OcppIdTag                   *string   `json:"ocpp_idTag,omitempty"`
		OcppServer                  *string   `json:"ocpp_server,omitempty"`
		OcppSuspendEvse             *bool     `json:"ocpp_suspend_evse,omitempty"`
		Offset                      *int      `json:"offset,omitempty"`
		Ohm                         *string   `json:"ohm,omitempty"`
		OhmEnabled                  *bool     `json:"ohm_enabled,omitempty"`
		Pass                        *string   `json:"pass,omitempty"`
		PauseUsesDisabled           *bool     `json:"pause_uses_disabled,omitempty"`
		Protocol                    *string   `json:"protocol,omitempty"`
		RelayCheck                  *bool     `json:"relay_check,omitempty"`
		Scale                       *int      `json:"scale,omitempty"`
		Service                     *int      `json:"service,omitempty"`
		SntpEnabled                 *bool     `json:"sntp_enabled,omitempty"`
		SntpHostname                *string   `json:"sntp_hostname,omitempty"`
		Ssid                        *string   `json:"ssid,omitempty"`
		TempCheck                   *bool     `json:"temp_check,omitempty"`
		TeslaAccessToken            *string   `json:"tesla_access_token,omitempty"`
		TeslaCreatedAt              *float32  `json:"tesla_created_at,omitempty"`
		TeslaEnabled                *bool     `json:"tesla_enabled,omitempty"`
		TeslaExpiresIn              *float32  `json:"tesla_expires_in,omitempty"`
		TeslaRefreshToken           *string   `json:"tesla_refresh_token,omitempty"`
		TeslaVehicleId              *string   `json:"tesla_vehicle_id,omitempty"`
		TimeZone                    *string   `json:"time_zone,omitempty"`
		TxStartPoint                *string   `json:"tx_start_point,omitempty"`
		VentCheck                   *bool     `json:"vent_check,omitempty"`
		Version                     *string   `json:"version,omitempty"`
		WwwPassword                 *string   `json:"www_password,omitempty"`
		WwwUsername                 *string   `json:"www_username,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Message
	JSON400      *Message
}

// Status returns HTTPResponse.Status
func (r UpdateConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEventBlockInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Max *int `json:"max,omitempty"`
		Min *int `json:"min,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetEventBlockInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEventBlockInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetEventBlockResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]LogEvent
	JSON404      *Message
}

// Status returns HTTPResponse.Status
func (r GetEventBlockResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEventBlockResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClearManualOverrideResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ClearManualOverrideResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClearManualOverrideResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetManualOverrideResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// `true` if the manual override is auto-released when the vehicle is
		// disconnected, `false` if manual override will persist after vehicle
		// disconnection.
		AutoRelease *bool `json:"auto_release,omitempty"`

		// Specify the active charge current in Amps
		ChargeCurrent *int `json:"charge_current,omitempty"`

		// Stop the charge after `energy_limit` Wh of energy have been transfered.
		//
		// > Note:  Not currently implemented
		EnergyLimit *int32 `json:"energy_limit,omitempty"`

		// Dynamically alter the max current while still allowing other claims to very the current via `charge_current` that can not exceede this value. This is primerialy designed for load sharing situations while still allowing things like PV divert to work so the charge current is the minimum of `charge_current` <= `max_current` <= configured soft limit <= hard coded limit
		MaxCurrent *int `json:"max_current,omitempty"`

		// Either enable charging (`active`) or block charging (`disabled`)
		State *string `json:"state,omitempty"`

		// Stop the charge after the duration of the charging session has exceeded `time_limit` seconds
		//
		// > Note:  Not currently implemented
		TimeLimit *int32 `json:"time_limit,omitempty"`
	}
	JSON404 *Message
}

// Status returns HTTPResponse.Status
func (r GetManualOverrideResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetManualOverrideResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ToggleManualOverrideResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ToggleManualOverrideResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ToggleManualOverrideResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetManualOverrideResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Message
}

// Status returns HTTPResponse.Status
func (r SetManualOverrideResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetManualOverrideResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]ScheduleEvent
	JSON400      *Message
}

// Status returns HTTPResponse.Status
func (r ListScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateScheduleResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UpdateScheduleResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateScheduleResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RemoveScheduleEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Message
}

// Status returns HTTPResponse.Status
func (r RemoveScheduleEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RemoveScheduleEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetScheduleEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *string
}

// Status returns HTTPResponse.Status
func (r GetScheduleEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetScheduleEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetScheduleEventResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Message
}

// Status returns HTTPResponse.Status
func (r SetScheduleEventResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetScheduleEventResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// the value of the charge current in mA
		Amp *float32 `json:"amp,omitempty"`

		// The computed avalible current for divert
		AvailableCurrent *int `json:"available_current,omitempty"`

		// The divert charge rate
		ChargeRate *int `json:"charge_rate,omitempty"`

		// The LCD colour
		Colour *int `json:"colour,omitempty"`

		// Number of RAPI messages sent
		CommSent *int `json:"comm_sent,omitempty"`

		// Number of successful RAPI messages
		CommSuccess *int `json:"comm_success,omitempty"`

		// `true` if divert is active, `false` if not
		DivertActive *bool `json:"divert_active,omitempty"`

		// The time since the last update of the divert feed
		DivertUpdate *float32 `json:"divert_update,omitempty"`

		// The PV divert mode, `1` normal, `2` Eco
		Divertmode *int `json:"divertmode,omitempty"`

		// The duration of the current charge session, in seconds
		Elapsed *float32 `json:"elapsed,omitempty"`

		// `1`, if connected to an EmonCMS server, `0` not connected
		EmoncmsConnected *int `json:"emoncms_connected,omitempty"`

		// Last response message from the EmonCMS server
		EmoncmsMessage *string `json:"emoncms_message,omitempty"`

		// `1`, Wired ethernet is connected, `0` no wired ethernet connection
		EthConnected *int `json:"eth_connected,omitempty"`

		// `1`, if the WiFi module has negociated a connection to the OpenEVSE module, `0` not connected
		EvseConnected *int `json:"evse_connected,omitempty"`

		// Number of bytes free in the ESP memory heap
		FreeHeap *int `json:"free_heap,omitempty"`

		// Number of GFCI errors
		Gfcicount *int `json:"gfcicount,omitempty"`

		// The latest grid +I/-E feed value received
		GridIe *int `json:"grid_ie,omitempty"`

		// The current IP address of the WiFi module
		Ipaddress *string `json:"ipaddress,omitempty"`

		// `1`, if the manual override is active, `0` default behaviour
		ManualOverride *int `json:"manual_override,omitempty"`

		// The current mode of the EVSE
		Mode *string `json:"mode,omitempty"`

		// `1`, if connected to an EmonCMS server, `0` not connected
		MqttConnected *int `json:"mqtt_connected,omitempty"`

		// `1`, network is connected, either wired or WiFi, `0` no network connection
		NetConnected *int `json:"net_connected,omitempty"`

		// Number of no ground errors
		Nogndcount *int `json:"nogndcount,omitempty"`

		// The current timezone
		Offset *string `json:"offset,omitempty"`

		// Last status message from the OhmHour connection
		OhmHour *string `json:"ohm_hour,omitempty"`

		// `1`, if there is an OTA update active, `0` if normal operation
		OtaUpdate *int `json:"ota_update,omitempty"`

		// The number of posts sent to the EmonCMS server
		PacketsSent *int `json:"packets_sent,omitempty"`

		// The number of successful posts to the EmonCMS server
		PacketsSuccess *int `json:"packets_success,omitempty"`

		// the pilot value, in amps
		Pilot *int `json:"pilot,omitempty"`

		// `1`, if RAPI messages have successfully been sent to the OpenEVSE module, `0` not connected
		RapiConnected *int `json:"rapi_connected,omitempty"`

		// The current service level
		ServiceLevel *int `json:"service_level,omitempty"`

		// The computed smoothed available current for divert
		SmoothedAvailableCurrent *int `json:"smoothed_available_current,omitempty"`

		// The latest solar feed value received
		Solar *int `json:"solar,omitempty"`

		// WiFi RSSI signal strength
		Srssi *int `json:"srssi,omitempty"`

		// The EVSE state
		State *int `json:"state,omitempty"`

		// The EVSE status
		Status *string `json:"status,omitempty"`

		// Number of stuck relay errors
		Stuckcount *int `json:"stuckcount,omitempty"`

		// the derived temperature, in 1/10th °C
		Temp *float32 `json:"temp,omitempty"`

		// The current time on the WiFi module
		Time *string `json:"time,omitempty"`

		// `1`, if a vehicle id connected to the EVSE, `0` not connected
		Vehicle *int `json:"vehicle,omitempty"`

		// the charge voltage, read form the EVSE if supported, or supplied via MQTT or other external source
		Voltage *float32 `json:"voltage,omitempty"`

		// The total amount of energy transfered, in W/hour
		Watthour *float32 `json:"watthour,omitempty"`

		// The amount of energy transfered in this charge session, in W/sec
		Wattsec *float32 `json:"wattsec,omitempty"`

		// `1`, WiFi is connected, `0` no WiFi connection
		WifiClientConnected *int `json:"wifi_client_connected,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTeslaVehiclesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Count    float32 `json:"count"`
		Vehicles []struct {
			Id   string `json:"id"`
			Name string `json:"name"`
		} `json:"vehicles"`
	}
}

// Status returns HTTPResponse.Status
func (r GetTeslaVehiclesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeslaVehiclesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StatusUpdatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// the value of the charge current in mA
		Amp *float32 `json:"amp,omitempty"`

		// The computed avalible current for divert
		AvailableCurrent *int `json:"available_current,omitempty"`

		// The divert charge rate
		ChargeRate *int `json:"charge_rate,omitempty"`

		// The LCD colour
		Colour *int `json:"colour,omitempty"`

		// Number of RAPI messages sent
		CommSent *int `json:"comm_sent,omitempty"`

		// Number of successful RAPI messages
		CommSuccess *int `json:"comm_success,omitempty"`

		// `true` if divert is active, `false` if not
		DivertActive *bool `json:"divert_active,omitempty"`

		// The time since the last update of the divert feed
		DivertUpdate *float32 `json:"divert_update,omitempty"`

		// The PV divert mode, `1` normal, `2` Eco
		Divertmode *int `json:"divertmode,omitempty"`

		// The duration of the current charge session, in seconds
		Elapsed *float32 `json:"elapsed,omitempty"`

		// `1`, if connected to an EmonCMS server, `0` not connected
		EmoncmsConnected *int `json:"emoncms_connected,omitempty"`

		// Last response message from the EmonCMS server
		EmoncmsMessage *string `json:"emoncms_message,omitempty"`

		// `1`, Wired ethernet is connected, `0` no wired ethernet connection
		EthConnected *int `json:"eth_connected,omitempty"`

		// `1`, if the WiFi module has negociated a connection to the OpenEVSE module, `0` not connected
		EvseConnected *int `json:"evse_connected,omitempty"`

		// Number of bytes free in the ESP memory heap
		FreeHeap *int `json:"free_heap,omitempty"`

		// Number of GFCI errors
		Gfcicount *int `json:"gfcicount,omitempty"`

		// The latest grid +I/-E feed value received
		GridIe *int `json:"grid_ie,omitempty"`

		// The current IP address of the WiFi module
		Ipaddress *string `json:"ipaddress,omitempty"`

		// `1`, if the manual override is active, `0` default behaviour
		ManualOverride *int `json:"manual_override,omitempty"`

		// The current mode of the EVSE
		Mode *string `json:"mode,omitempty"`

		// `1`, if connected to an EmonCMS server, `0` not connected
		MqttConnected *int `json:"mqtt_connected,omitempty"`

		// `1`, network is connected, either wired or WiFi, `0` no network connection
		NetConnected *int `json:"net_connected,omitempty"`

		// Number of no ground errors
		Nogndcount *int `json:"nogndcount,omitempty"`

		// The current timezone
		Offset *string `json:"offset,omitempty"`

		// Last status message from the OhmHour connection
		OhmHour *string `json:"ohm_hour,omitempty"`

		// `1`, if there is an OTA update active, `0` if normal operation
		OtaUpdate *int `json:"ota_update,omitempty"`

		// The number of posts sent to the EmonCMS server
		PacketsSent *int `json:"packets_sent,omitempty"`

		// The number of successful posts to the EmonCMS server
		PacketsSuccess *int `json:"packets_success,omitempty"`

		// the pilot value, in amps
		Pilot *int `json:"pilot,omitempty"`

		// `1`, if RAPI messages have successfully been sent to the OpenEVSE module, `0` not connected
		RapiConnected *int `json:"rapi_connected,omitempty"`

		// The current service level
		ServiceLevel *int `json:"service_level,omitempty"`

		// The computed smoothed available current for divert
		SmoothedAvailableCurrent *int `json:"smoothed_available_current,omitempty"`

		// The latest solar feed value received
		Solar *int `json:"solar,omitempty"`

		// WiFi RSSI signal strength
		Srssi *int `json:"srssi,omitempty"`

		// The EVSE status
		State *int `json:"state,omitempty"`

		// Number of stuck relay errors
		Stuckcount *int `json:"stuckcount,omitempty"`

		// the derived temperature, in 1/10th °C
		Temp *float32 `json:"temp,omitempty"`

		// The current time on the WiFi module
		Time *string `json:"time,omitempty"`

		// `1`, if a vehicle id connected to the EVSE, `0` not connected
		Vehicle *int `json:"vehicle,omitempty"`

		// the charge voltage, read form the EVSE if supported, or supplied via MQTT or other external source
		Voltage *float32 `json:"voltage,omitempty"`

		// The total amount of energy transfered, in W/hour
		Watthour *float32 `json:"watthour,omitempty"`

		// The amount of energy transfered in this charge session, in W/sec
		Wattsec *float32 `json:"wattsec,omitempty"`

		// `1`, WiFi is connected, `0` no WiFi connection
		WifiClientConnected *int `json:"wifi_client_connected,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r StatusUpdatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StatusUpdatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListClaimsWithResponse request returning *ListClaimsResponse
func (c *ClientWithResponses) ListClaimsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListClaimsResponse, error) {
	rsp, err := c.ListClaims(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListClaimsResponse(rsp)
}

// ReleaseClaimWithResponse request returning *ReleaseClaimResponse
func (c *ClientWithResponses) ReleaseClaimWithResponse(ctx context.Context, client int, reqEditors ...RequestEditorFn) (*ReleaseClaimResponse, error) {
	rsp, err := c.ReleaseClaim(ctx, client, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReleaseClaimResponse(rsp)
}

// GetClaimWithResponse request returning *GetClaimResponse
func (c *ClientWithResponses) GetClaimWithResponse(ctx context.Context, client int, reqEditors ...RequestEditorFn) (*GetClaimResponse, error) {
	rsp, err := c.GetClaim(ctx, client, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetClaimResponse(rsp)
}

// SetClaimWithBodyWithResponse request with arbitrary body returning *SetClaimResponse
func (c *ClientWithResponses) SetClaimWithBodyWithResponse(ctx context.Context, client int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetClaimResponse, error) {
	rsp, err := c.SetClaimWithBody(ctx, client, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetClaimResponse(rsp)
}

func (c *ClientWithResponses) SetClaimWithResponse(ctx context.Context, client int, body SetClaimJSONRequestBody, reqEditors ...RequestEditorFn) (*SetClaimResponse, error) {
	rsp, err := c.SetClaim(ctx, client, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetClaimResponse(rsp)
}

// GetConfigWithResponse request returning *GetConfigResponse
func (c *ClientWithResponses) GetConfigWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetConfigResponse, error) {
	rsp, err := c.GetConfig(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigResponse(rsp)
}

// UpdateConfigWithBodyWithResponse request with arbitrary body returning *UpdateConfigResponse
func (c *ClientWithResponses) UpdateConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateConfigResponse, error) {
	rsp, err := c.UpdateConfigWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateConfigResponse(rsp)
}

func (c *ClientWithResponses) UpdateConfigWithResponse(ctx context.Context, body UpdateConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateConfigResponse, error) {
	rsp, err := c.UpdateConfig(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateConfigResponse(rsp)
}

// GetEventBlockInfoWithResponse request returning *GetEventBlockInfoResponse
func (c *ClientWithResponses) GetEventBlockInfoWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetEventBlockInfoResponse, error) {
	rsp, err := c.GetEventBlockInfo(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEventBlockInfoResponse(rsp)
}

// GetEventBlockWithResponse request returning *GetEventBlockResponse
func (c *ClientWithResponses) GetEventBlockWithResponse(ctx context.Context, index int, reqEditors ...RequestEditorFn) (*GetEventBlockResponse, error) {
	rsp, err := c.GetEventBlock(ctx, index, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetEventBlockResponse(rsp)
}

// ClearManualOverrideWithResponse request returning *ClearManualOverrideResponse
func (c *ClientWithResponses) ClearManualOverrideWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ClearManualOverrideResponse, error) {
	rsp, err := c.ClearManualOverride(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClearManualOverrideResponse(rsp)
}

// GetManualOverrideWithResponse request returning *GetManualOverrideResponse
func (c *ClientWithResponses) GetManualOverrideWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetManualOverrideResponse, error) {
	rsp, err := c.GetManualOverride(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetManualOverrideResponse(rsp)
}

// ToggleManualOverrideWithResponse request returning *ToggleManualOverrideResponse
func (c *ClientWithResponses) ToggleManualOverrideWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ToggleManualOverrideResponse, error) {
	rsp, err := c.ToggleManualOverride(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseToggleManualOverrideResponse(rsp)
}

// SetManualOverrideWithBodyWithResponse request with arbitrary body returning *SetManualOverrideResponse
func (c *ClientWithResponses) SetManualOverrideWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetManualOverrideResponse, error) {
	rsp, err := c.SetManualOverrideWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetManualOverrideResponse(rsp)
}

func (c *ClientWithResponses) SetManualOverrideWithResponse(ctx context.Context, body SetManualOverrideJSONRequestBody, reqEditors ...RequestEditorFn) (*SetManualOverrideResponse, error) {
	rsp, err := c.SetManualOverride(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetManualOverrideResponse(rsp)
}

// ListScheduleWithResponse request returning *ListScheduleResponse
func (c *ClientWithResponses) ListScheduleWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListScheduleResponse, error) {
	rsp, err := c.ListSchedule(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListScheduleResponse(rsp)
}

// UpdateScheduleWithBodyWithResponse request with arbitrary body returning *UpdateScheduleResponse
func (c *ClientWithResponses) UpdateScheduleWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateScheduleResponse, error) {
	rsp, err := c.UpdateScheduleWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateScheduleResponse(rsp)
}

func (c *ClientWithResponses) UpdateScheduleWithResponse(ctx context.Context, body UpdateScheduleJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateScheduleResponse, error) {
	rsp, err := c.UpdateSchedule(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateScheduleResponse(rsp)
}

// RemoveScheduleEventWithResponse request returning *RemoveScheduleEventResponse
func (c *ClientWithResponses) RemoveScheduleEventWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*RemoveScheduleEventResponse, error) {
	rsp, err := c.RemoveScheduleEvent(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRemoveScheduleEventResponse(rsp)
}

// GetScheduleEventWithResponse request returning *GetScheduleEventResponse
func (c *ClientWithResponses) GetScheduleEventWithResponse(ctx context.Context, id int, reqEditors ...RequestEditorFn) (*GetScheduleEventResponse, error) {
	rsp, err := c.GetScheduleEvent(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetScheduleEventResponse(rsp)
}

// SetScheduleEventWithBodyWithResponse request with arbitrary body returning *SetScheduleEventResponse
func (c *ClientWithResponses) SetScheduleEventWithBodyWithResponse(ctx context.Context, id int, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetScheduleEventResponse, error) {
	rsp, err := c.SetScheduleEventWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetScheduleEventResponse(rsp)
}

func (c *ClientWithResponses) SetScheduleEventWithResponse(ctx context.Context, id int, body SetScheduleEventJSONRequestBody, reqEditors ...RequestEditorFn) (*SetScheduleEventResponse, error) {
	rsp, err := c.SetScheduleEvent(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetScheduleEventResponse(rsp)
}

// GetStatusWithResponse request returning *GetStatusResponse
func (c *ClientWithResponses) GetStatusWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetStatusResponse, error) {
	rsp, err := c.GetStatus(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStatusResponse(rsp)
}

// GetTeslaVehiclesWithResponse request returning *GetTeslaVehiclesResponse
func (c *ClientWithResponses) GetTeslaVehiclesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetTeslaVehiclesResponse, error) {
	rsp, err := c.GetTeslaVehicles(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTeslaVehiclesResponse(rsp)
}

// StatusUpdatesWithResponse request returning *StatusUpdatesResponse
func (c *ClientWithResponses) StatusUpdatesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*StatusUpdatesResponse, error) {
	rsp, err := c.StatusUpdates(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStatusUpdatesResponse(rsp)
}

// ParseListClaimsResponse parses an HTTP response from a ListClaimsWithResponse call
func ParseListClaimsResponse(rsp *http.Response) (*ListClaimsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListClaimsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// `true` if the manual override is auto-released when the vehicle is
			// disconnected, `false` if manual override will persist after vehicle
			// disconnection.
			AutoRelease *bool `json:"auto_release,omitempty"`

			// Specify the active charge current in Amps
			ChargeCurrent *int `json:"charge_current,omitempty"`

			// The client ID, defined by [OpenEVSE](src/evse_man.h#L25)
			Client *int `json:"client,omitempty"`

			// Stop the charge after `energy_limit` Wh of energy have been transfered.
			//
			// > Note:  Not currently implemented
			EnergyLimit *int32 `json:"energy_limit,omitempty"`

			// Dynamically alter the max current while still allowing other claims to very the current via `charge_current` that can not exceede this value. This is primerialy designed for load sharing situations while still allowing things like PV divert to work so the charge current is the minimum of `charge_current` <= `max_current` <= configured soft limit <= hard coded limit
			MaxCurrent *int `json:"max_current,omitempty"`

			// The priority of the claim, the higher the number the higher the priority
			Priority *int `json:"priority,omitempty"`

			// Either enable charging (`active`) or block charging (`disabled`)
			State *string `json:"state,omitempty"`

			// Stop the charge after the duration of the charging session has exceeded `time_limit` seconds
			//
			// > Note:  Not currently implemented
			TimeLimit *int32 `json:"time_limit,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReleaseClaimResponse parses an HTTP response from a ReleaseClaimWithResponse call
func ParseReleaseClaimResponse(rsp *http.Response) (*ReleaseClaimResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReleaseClaimResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Message
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Message
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetClaimResponse parses an HTTP response from a GetClaimWithResponse call
func ParseGetClaimResponse(rsp *http.Response) (*GetClaimResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetClaimResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// `true` if the manual override is auto-released when the vehicle is
			// disconnected, `false` if manual override will persist after vehicle
			// disconnection.
			AutoRelease *bool `json:"auto_release,omitempty"`

			// Specify the active charge current in Amps
			ChargeCurrent *int `json:"charge_current,omitempty"`

			// Stop the charge after `energy_limit` Wh of energy have been transfered.
			//
			// > Note:  Not currently implemented
			EnergyLimit *int32 `json:"energy_limit,omitempty"`

			// Dynamically alter the max current while still allowing other claims to very the current via `charge_current` that can not exceede this value. This is primerialy designed for load sharing situations while still allowing things like PV divert to work so the charge current is the minimum of `charge_current` <= `max_current` <= configured soft limit <= hard coded limit
			MaxCurrent *int `json:"max_current,omitempty"`

			// Either enable charging (`active`) or block charging (`disabled`)
			State *string `json:"state,omitempty"`

			// Stop the charge after the duration of the charging session has exceeded `time_limit` seconds
			//
			// > Note:  Not currently implemented
			TimeLimit *int32 `json:"time_limit,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Message
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSetClaimResponse parses an HTTP response from a SetClaimWithResponse call
func ParseSetClaimResponse(rsp *http.Response) (*SetClaimResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetClaimResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Message
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Message
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetConfigResponse parses an HTTP response from a GetConfigWithResponse call
func ParseGetConfigResponse(rsp *http.Response) (*GetConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Buildenv                    *string   `json:"buildenv,omitempty"`
			ChargeMode                  *string   `json:"charge_mode,omitempty"`
			DiodeCheck                  *bool     `json:"diode_check,omitempty"`
			DivertPVRatio               *float32  `json:"divert_PV_ratio,omitempty"`
			DivertAttackSmoothingFactor *float32  `json:"divert_attack_smoothing_factor,omitempty"`
			DivertDecaySmoothingFactor  *float32  `json:"divert_decay_smoothing_factor,omitempty"`
			DivertEnabled               *bool     `json:"divert_enabled,omitempty"`
			DivertMinChargeTime         *float32  `json:"divert_min_charge_time,omitempty"`
			EmoncmsApikey               *string   `json:"emoncms_apikey,omitempty"`
			EmoncmsEnabled              *bool     `json:"emoncms_enabled,omitempty"`
			EmoncmsFingerprint          *string   `json:"emoncms_fingerprint,omitempty"`
			EmoncmsNode                 *string   `json:"emoncms_node,omitempty"`
			EmoncmsServer               *string   `json:"emoncms_server,omitempty"`
			Espflash                    *float32  `json:"espflash,omitempty"`
			Espinfo                     *string   `json:"espinfo,omitempty"`
			Firmware                    *string   `json:"firmware,omitempty"`
			Flags                       *float32  `json:"flags,omitempty"`
			GfciCheck                   *bool     `json:"gfci_check,omitempty"`
			GroundCheck                 *bool     `json:"ground_check,omitempty"`
			Hostname                    *string   `json:"hostname,omitempty"`
			HttpSupportedProtocols      *[]string `json:"http_supported_protocols,omitempty"`
			LedBrightness               *float32  `json:"led_brightness,omitempty"`
			MaxCurrentHard              *int      `json:"max_current_hard,omitempty"`
			MaxCurrentSoft              *int      `json:"max_current_soft,omitempty"`
			MinCurrentHard              *int      `json:"min_current_hard,omitempty"`
			MqttAnnounceTopic           *string   `json:"mqtt_announce_topic,omitempty"`
			MqttEnabled                 *bool     `json:"mqtt_enabled,omitempty"`
			MqttGridIe                  *string   `json:"mqtt_grid_ie,omitempty"`
			MqttPass                    *string   `json:"mqtt_pass,omitempty"`
			MqttPort                    *int      `json:"mqtt_port,omitempty"`
			MqttProtocol                *string   `json:"mqtt_protocol,omitempty"`
			MqttRejectUnauthorized      *bool     `json:"mqtt_reject_unauthorized,omitempty"`
			MqttServer                  *string   `json:"mqtt_server,omitempty"`
			MqttSolar                   *string   `json:"mqtt_solar,omitempty"`
			MqttSupportedProtocols      *[]string `json:"mqtt_supported_protocols,omitempty"`
			MqttTopic                   *string   `json:"mqtt_topic,omitempty"`
			MqttUser                    *string   `json:"mqtt_user,omitempty"`
			MqttVehicleEta              *string   `json:"mqtt_vehicle_eta,omitempty"`
			MqttVehicleRange            *string   `json:"mqtt_vehicle_range,omitempty"`
			MqttVehicleRangeMiles       *bool     `json:"mqtt_vehicle_range_miles,omitempty"`
			MqttVehicleSoc              *string   `json:"mqtt_vehicle_soc,omitempty"`
			MqttVrms                    *string   `json:"mqtt_vrms,omitempty"`
			OcppChargeBoxId             *string   `json:"ocpp_chargeBoxId,omitempty"`
			OcppEnabled                 *bool     `json:"ocpp_enabled,omitempty"`
			OcppEnergizePlug            *bool     `json:"ocpp_energize_plug,omitempty"`
			OcppIdTag                   *string   `json:"ocpp_idTag,omitempty"`
			OcppServer                  *string   `json:"ocpp_server,omitempty"`
			OcppSuspendEvse             *bool     `json:"ocpp_suspend_evse,omitempty"`
			Offset                      *int      `json:"offset,omitempty"`
			Ohm                         *string   `json:"ohm,omitempty"`
			OhmEnabled                  *bool     `json:"ohm_enabled,omitempty"`
			Pass                        *string   `json:"pass,omitempty"`
			PauseUsesDisabled           *bool     `json:"pause_uses_disabled,omitempty"`
			Protocol                    *string   `json:"protocol,omitempty"`
			RelayCheck                  *bool     `json:"relay_check,omitempty"`
			Scale                       *int      `json:"scale,omitempty"`
			Service                     *int      `json:"service,omitempty"`
			SntpEnabled                 *bool     `json:"sntp_enabled,omitempty"`
			SntpHostname                *string   `json:"sntp_hostname,omitempty"`
			Ssid                        *string   `json:"ssid,omitempty"`
			TempCheck                   *bool     `json:"temp_check,omitempty"`
			TeslaAccessToken            *string   `json:"tesla_access_token,omitempty"`
			TeslaCreatedAt              *float32  `json:"tesla_created_at,omitempty"`
			TeslaEnabled                *bool     `json:"tesla_enabled,omitempty"`
			TeslaExpiresIn              *float32  `json:"tesla_expires_in,omitempty"`
			TeslaRefreshToken           *string   `json:"tesla_refresh_token,omitempty"`
			TeslaVehicleId              *string   `json:"tesla_vehicle_id,omitempty"`
			TimeZone                    *string   `json:"time_zone,omitempty"`
			TxStartPoint                *string   `json:"tx_start_point,omitempty"`
			VentCheck                   *bool     `json:"vent_check,omitempty"`
			Version                     *string   `json:"version,omitempty"`
			WwwPassword                 *string   `json:"www_password,omitempty"`
			WwwUsername                 *string   `json:"www_username,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateConfigResponse parses an HTTP response from a UpdateConfigWithResponse call
func ParseUpdateConfigResponse(rsp *http.Response) (*UpdateConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Message
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Message
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetEventBlockInfoResponse parses an HTTP response from a GetEventBlockInfoWithResponse call
func ParseGetEventBlockInfoResponse(rsp *http.Response) (*GetEventBlockInfoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEventBlockInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Max *int `json:"max,omitempty"`
			Min *int `json:"min,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetEventBlockResponse parses an HTTP response from a GetEventBlockWithResponse call
func ParseGetEventBlockResponse(rsp *http.Response) (*GetEventBlockResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetEventBlockResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []LogEvent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Message
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseClearManualOverrideResponse parses an HTTP response from a ClearManualOverrideWithResponse call
func ParseClearManualOverrideResponse(rsp *http.Response) (*ClearManualOverrideResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClearManualOverrideResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetManualOverrideResponse parses an HTTP response from a GetManualOverrideWithResponse call
func ParseGetManualOverrideResponse(rsp *http.Response) (*GetManualOverrideResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetManualOverrideResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// `true` if the manual override is auto-released when the vehicle is
			// disconnected, `false` if manual override will persist after vehicle
			// disconnection.
			AutoRelease *bool `json:"auto_release,omitempty"`

			// Specify the active charge current in Amps
			ChargeCurrent *int `json:"charge_current,omitempty"`

			// Stop the charge after `energy_limit` Wh of energy have been transfered.
			//
			// > Note:  Not currently implemented
			EnergyLimit *int32 `json:"energy_limit,omitempty"`

			// Dynamically alter the max current while still allowing other claims to very the current via `charge_current` that can not exceede this value. This is primerialy designed for load sharing situations while still allowing things like PV divert to work so the charge current is the minimum of `charge_current` <= `max_current` <= configured soft limit <= hard coded limit
			MaxCurrent *int `json:"max_current,omitempty"`

			// Either enable charging (`active`) or block charging (`disabled`)
			State *string `json:"state,omitempty"`

			// Stop the charge after the duration of the charging session has exceeded `time_limit` seconds
			//
			// > Note:  Not currently implemented
			TimeLimit *int32 `json:"time_limit,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Message
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseToggleManualOverrideResponse parses an HTTP response from a ToggleManualOverrideWithResponse call
func ParseToggleManualOverrideResponse(rsp *http.Response) (*ToggleManualOverrideResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ToggleManualOverrideResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetManualOverrideResponse parses an HTTP response from a SetManualOverrideWithResponse call
func ParseSetManualOverrideResponse(rsp *http.Response) (*SetManualOverrideResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetManualOverrideResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Message
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListScheduleResponse parses an HTTP response from a ListScheduleWithResponse call
func ParseListScheduleResponse(rsp *http.Response) (*ListScheduleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []ScheduleEvent
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Message
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseUpdateScheduleResponse parses an HTTP response from a UpdateScheduleWithResponse call
func ParseUpdateScheduleResponse(rsp *http.Response) (*UpdateScheduleResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateScheduleResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseRemoveScheduleEventResponse parses an HTTP response from a RemoveScheduleEventWithResponse call
func ParseRemoveScheduleEventResponse(rsp *http.Response) (*RemoveScheduleEventResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RemoveScheduleEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Message
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetScheduleEventResponse parses an HTTP response from a GetScheduleEventWithResponse call
func ParseGetScheduleEventResponse(rsp *http.Response) (*GetScheduleEventResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetScheduleEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetScheduleEventResponse parses an HTTP response from a SetScheduleEventWithResponse call
func ParseSetScheduleEventResponse(rsp *http.Response) (*SetScheduleEventResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetScheduleEventResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Message
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetStatusResponse parses an HTTP response from a GetStatusWithResponse call
func ParseGetStatusResponse(rsp *http.Response) (*GetStatusResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// the value of the charge current in mA
			Amp *float32 `json:"amp,omitempty"`

			// The computed avalible current for divert
			AvailableCurrent *int `json:"available_current,omitempty"`

			// The divert charge rate
			ChargeRate *int `json:"charge_rate,omitempty"`

			// The LCD colour
			Colour *int `json:"colour,omitempty"`

			// Number of RAPI messages sent
			CommSent *int `json:"comm_sent,omitempty"`

			// Number of successful RAPI messages
			CommSuccess *int `json:"comm_success,omitempty"`

			// `true` if divert is active, `false` if not
			DivertActive *bool `json:"divert_active,omitempty"`

			// The time since the last update of the divert feed
			DivertUpdate *float32 `json:"divert_update,omitempty"`

			// The PV divert mode, `1` normal, `2` Eco
			Divertmode *int `json:"divertmode,omitempty"`

			// The duration of the current charge session, in seconds
			Elapsed *float32 `json:"elapsed,omitempty"`

			// `1`, if connected to an EmonCMS server, `0` not connected
			EmoncmsConnected *int `json:"emoncms_connected,omitempty"`

			// Last response message from the EmonCMS server
			EmoncmsMessage *string `json:"emoncms_message,omitempty"`

			// `1`, Wired ethernet is connected, `0` no wired ethernet connection
			EthConnected *int `json:"eth_connected,omitempty"`

			// `1`, if the WiFi module has negociated a connection to the OpenEVSE module, `0` not connected
			EvseConnected *int `json:"evse_connected,omitempty"`

			// Number of bytes free in the ESP memory heap
			FreeHeap *int `json:"free_heap,omitempty"`

			// Number of GFCI errors
			Gfcicount *int `json:"gfcicount,omitempty"`

			// The latest grid +I/-E feed value received
			GridIe *int `json:"grid_ie,omitempty"`

			// The current IP address of the WiFi module
			Ipaddress *string `json:"ipaddress,omitempty"`

			// `1`, if the manual override is active, `0` default behaviour
			ManualOverride *int `json:"manual_override,omitempty"`

			// The current mode of the EVSE
			Mode *string `json:"mode,omitempty"`

			// `1`, if connected to an EmonCMS server, `0` not connected
			MqttConnected *int `json:"mqtt_connected,omitempty"`

			// `1`, network is connected, either wired or WiFi, `0` no network connection
			NetConnected *int `json:"net_connected,omitempty"`

			// Number of no ground errors
			Nogndcount *int `json:"nogndcount,omitempty"`

			// The current timezone
			Offset *string `json:"offset,omitempty"`

			// Last status message from the OhmHour connection
			OhmHour *string `json:"ohm_hour,omitempty"`

			// `1`, if there is an OTA update active, `0` if normal operation
			OtaUpdate *int `json:"ota_update,omitempty"`

			// The number of posts sent to the EmonCMS server
			PacketsSent *int `json:"packets_sent,omitempty"`

			// The number of successful posts to the EmonCMS server
			PacketsSuccess *int `json:"packets_success,omitempty"`

			// the pilot value, in amps
			Pilot *int `json:"pilot,omitempty"`

			// `1`, if RAPI messages have successfully been sent to the OpenEVSE module, `0` not connected
			RapiConnected *int `json:"rapi_connected,omitempty"`

			// The current service level
			ServiceLevel *int `json:"service_level,omitempty"`

			// The computed smoothed available current for divert
			SmoothedAvailableCurrent *int `json:"smoothed_available_current,omitempty"`

			// The latest solar feed value received
			Solar *int `json:"solar,omitempty"`

			// WiFi RSSI signal strength
			Srssi *int `json:"srssi,omitempty"`

			// The EVSE state
			State *int `json:"state,omitempty"`

			// The EVSE status
			Status *string `json:"status,omitempty"`

			// Number of stuck relay errors
			Stuckcount *int `json:"stuckcount,omitempty"`

			// the derived temperature, in 1/10th °C
			Temp *float32 `json:"temp,omitempty"`

			// The current time on the WiFi module
			Time *string `json:"time,omitempty"`

			// `1`, if a vehicle id connected to the EVSE, `0` not connected
			Vehicle *int `json:"vehicle,omitempty"`

			// the charge voltage, read form the EVSE if supported, or supplied via MQTT or other external source
			Voltage *float32 `json:"voltage,omitempty"`

			// The total amount of energy transfered, in W/hour
			Watthour *float32 `json:"watthour,omitempty"`

			// The amount of energy transfered in this charge session, in W/sec
			Wattsec *float32 `json:"wattsec,omitempty"`

			// `1`, WiFi is connected, `0` no WiFi connection
			WifiClientConnected *int `json:"wifi_client_connected,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTeslaVehiclesResponse parses an HTTP response from a GetTeslaVehiclesWithResponse call
func ParseGetTeslaVehiclesResponse(rsp *http.Response) (*GetTeslaVehiclesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTeslaVehiclesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Count    float32 `json:"count"`
			Vehicles []struct {
				Id   string `json:"id"`
				Name string `json:"name"`
			} `json:"vehicles"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseStatusUpdatesResponse parses an HTTP response from a StatusUpdatesWithResponse call
func ParseStatusUpdatesResponse(rsp *http.Response) (*StatusUpdatesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StatusUpdatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// the value of the charge current in mA
			Amp *float32 `json:"amp,omitempty"`

			// The computed avalible current for divert
			AvailableCurrent *int `json:"available_current,omitempty"`

			// The divert charge rate
			ChargeRate *int `json:"charge_rate,omitempty"`

			// The LCD colour
			Colour *int `json:"colour,omitempty"`

			// Number of RAPI messages sent
			CommSent *int `json:"comm_sent,omitempty"`

			// Number of successful RAPI messages
			CommSuccess *int `json:"comm_success,omitempty"`

			// `true` if divert is active, `false` if not
			DivertActive *bool `json:"divert_active,omitempty"`

			// The time since the last update of the divert feed
			DivertUpdate *float32 `json:"divert_update,omitempty"`

			// The PV divert mode, `1` normal, `2` Eco
			Divertmode *int `json:"divertmode,omitempty"`

			// The duration of the current charge session, in seconds
			Elapsed *float32 `json:"elapsed,omitempty"`

			// `1`, if connected to an EmonCMS server, `0` not connected
			EmoncmsConnected *int `json:"emoncms_connected,omitempty"`

			// Last response message from the EmonCMS server
			EmoncmsMessage *string `json:"emoncms_message,omitempty"`

			// `1`, Wired ethernet is connected, `0` no wired ethernet connection
			EthConnected *int `json:"eth_connected,omitempty"`

			// `1`, if the WiFi module has negociated a connection to the OpenEVSE module, `0` not connected
			EvseConnected *int `json:"evse_connected,omitempty"`

			// Number of bytes free in the ESP memory heap
			FreeHeap *int `json:"free_heap,omitempty"`

			// Number of GFCI errors
			Gfcicount *int `json:"gfcicount,omitempty"`

			// The latest grid +I/-E feed value received
			GridIe *int `json:"grid_ie,omitempty"`

			// The current IP address of the WiFi module
			Ipaddress *string `json:"ipaddress,omitempty"`

			// `1`, if the manual override is active, `0` default behaviour
			ManualOverride *int `json:"manual_override,omitempty"`

			// The current mode of the EVSE
			Mode *string `json:"mode,omitempty"`

			// `1`, if connected to an EmonCMS server, `0` not connected
			MqttConnected *int `json:"mqtt_connected,omitempty"`

			// `1`, network is connected, either wired or WiFi, `0` no network connection
			NetConnected *int `json:"net_connected,omitempty"`

			// Number of no ground errors
			Nogndcount *int `json:"nogndcount,omitempty"`

			// The current timezone
			Offset *string `json:"offset,omitempty"`

			// Last status message from the OhmHour connection
			OhmHour *string `json:"ohm_hour,omitempty"`

			// `1`, if there is an OTA update active, `0` if normal operation
			OtaUpdate *int `json:"ota_update,omitempty"`

			// The number of posts sent to the EmonCMS server
			PacketsSent *int `json:"packets_sent,omitempty"`

			// The number of successful posts to the EmonCMS server
			PacketsSuccess *int `json:"packets_success,omitempty"`

			// the pilot value, in amps
			Pilot *int `json:"pilot,omitempty"`

			// `1`, if RAPI messages have successfully been sent to the OpenEVSE module, `0` not connected
			RapiConnected *int `json:"rapi_connected,omitempty"`

			// The current service level
			ServiceLevel *int `json:"service_level,omitempty"`

			// The computed smoothed available current for divert
			SmoothedAvailableCurrent *int `json:"smoothed_available_current,omitempty"`

			// The latest solar feed value received
			Solar *int `json:"solar,omitempty"`

			// WiFi RSSI signal strength
			Srssi *int `json:"srssi,omitempty"`

			// The EVSE status
			State *int `json:"state,omitempty"`

			// Number of stuck relay errors
			Stuckcount *int `json:"stuckcount,omitempty"`

			// the derived temperature, in 1/10th °C
			Temp *float32 `json:"temp,omitempty"`

			// The current time on the WiFi module
			Time *string `json:"time,omitempty"`

			// `1`, if a vehicle id connected to the EVSE, `0` not connected
			Vehicle *int `json:"vehicle,omitempty"`

			// the charge voltage, read form the EVSE if supported, or supplied via MQTT or other external source
			Voltage *float32 `json:"voltage,omitempty"`

			// The total amount of energy transfered, in W/hour
			Watthour *float32 `json:"watthour,omitempty"`

			// The amount of energy transfered in this charge session, in W/sec
			Wattsec *float32 `json:"wattsec,omitempty"`

			// `1`, WiFi is connected, `0` no WiFi connection
			WifiClientConnected *int `json:"wifi_client_connected,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}
